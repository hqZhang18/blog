<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JS作用域和闭包 | 小乔的博客[学习笔记]|[生活随笔]</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="JS作用域和闭包">
<meta property="og:url" content="/conding/JavaScript/20170218/JS作用域和闭包.html">
<meta property="og:site_name" content="小乔的博客[学习笔记]|[生活随笔]">
<meta property="og:description" content="作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。">
<meta property="og:image" content="/css/images/scope.jpg">
<meta property="og:updated_time" content="2017-02-20T23:25:54.073Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS作用域和闭包">
<meta name="twitter:description" content="作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。">
<meta name="twitter:image" content="/css/images/scope.jpg">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
     		保持学习的习惯，努力的姿态！<br/>
     		享受生命的成长过程，创造美好未来送给自己<br/>
     		人生仅此一次，唯努力过方无悔
      
        <h2 id="subtitle-wrap" style="display: none;">
          <a href="/" id="subtitle">前端的那点事 前端笔记 es6 javascript es6 基础 react</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/categories/conding">学无止境</a>
        
          <a class="main-nav-link" href="/categories/life">碎言碎语</a>
        
          <a class="main-nav-link" href="/about">关于我</a>
        
      </nav>
      <nav id="sub-nav">
          <a class="nav-icon" href="https://github.com/jodyzhq" title="GitHub" target="_blank"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value=""></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JS作用域和闭包" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">

    

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS作用域和闭包
    </h1>
  

      </header>
    
 <div class="article-meta">
    <a href="/conding/JavaScript/20170218/JS作用域和闭包.html" class="article-date">
  <time datetime="2017-02-18T15:18:13.000Z" itemprop="datePublished">2017-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/conding/">技术</a>►<a class="article-category-link" href="/categories/conding/JavaScript/">JavaScript</a>
  </div>

   
  </div>
    <div class="article-entry article-all" itemprop="articleBody">

      
      	 
        <!-- Table of Contents -->
        
        <p>作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。<br><a id="more"></a></p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。</p>
<p>全局作用域（Global Scope）</p>
<p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：</p>
<p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="string">"global"</span>;     <span class="comment">// 显式声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> global;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);       <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，global 是全局变量，不管是在 checkscope() 函数内部还是外部，都能访问到全局变量 global。</p>
<p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>; <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    global = <span class="string">"global"</span>;   <span class="comment">// 隐式声明一个全局变量(不好的写法)</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);     <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);      <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量 global 未用 var 关键字定义就直接赋值，所以隐式的创建了全局变量 global，但这种写法容易造成误解，应尽量避免这种写法。</p>
<p>3.所有 window 对象的属性拥有全局作用域</p>
<p>一般情况下，window 对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等等。</p>
<p>局部作用域（Local Scope）</p>
<p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> local;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，在函数体内定义了变量 local，在函数体内是可以访问了，在函数外访问就报错了。</p>
<p>全局和局部作用域的关系</p>
<p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;      <span class="comment">// 声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;   <span class="comment">// 声明一个同名的局部变量</span></div><div class="line">    <span class="keyword">return</span> scope;          <span class="comment">// 返回局部变量的值，而不是全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div><div class="line">尽管在全局作用域编写代码时可以不写 <span class="keyword">var</span> 语句，但声明局部变量时则必须使用 <span class="keyword">var</span> 语句。思考一下如果不这样做会怎样：</div><div class="line"></div><div class="line">scope = <span class="string">"global"</span>;           <span class="comment">// 声明一个全局变量，甚至不用 var 来声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    scope = <span class="string">"local"</span>;        <span class="comment">// 糟糕！我们刚修改了全局变量</span></div><div class="line">    myscope = <span class="string">"local"</span>;      <span class="comment">// 这里显式地声明了一个新的全局变量</span></div><div class="line">    <span class="keyword">return</span> [scope, myscope];<span class="comment">// 返回两个值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope2()); <span class="comment">// ["local", "local"]，产生了副作用</span></div><div class="line"><span class="built_in">console</span>.log(scope);         <span class="comment">// "local"，全局变量修改了</span></div><div class="line"><span class="built_in">console</span>.log(myscope);       <span class="comment">// "local"，全局命名空间搞乱了</span></div></pre></td></tr></table></figure></p>
<p>函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：<br>javascript<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var scope = &quot;global scope&quot;;         // 全局变量</div><div class="line">function checkscope() &#123;</div><div class="line">    var scope = &quot;local scope&quot;;      //局部变量 </div><div class="line">    function nested() &#123;</div><div class="line">        var scope = &quot;nested scope&quot;; // 嵌套作用域内的局部变量</div><div class="line">        return scope;               // 返回当前作用域内的值</div><div class="line">    &#125;</div><div class="line">    return nested();</div><div class="line">&#125;</div><div class="line">console.log(checkscope());          // &quot;nested scope&quot;</div></pre></td></tr></table></figure></p>
<p>函数作用域和声明提前</p>
<p>在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>
<p>在如下所示的代码中，在不同位置定义了变量 i、j 和 k，它们都在同一个作用域内，这三个变量在函数体内均是有定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function test(o) &#123;</div><div class="line">    var i = 0; // i在整个函数体内均是有定义的</div><div class="line">    if (typeof o == &quot;object&quot;) &#123;</div><div class="line">        var j = 0; // j在函数体内是有定义的，不仅仅是在这个代码段内</div><div class="line">        for (var k = 0; k &lt; 10; k++) &#123; // k在函数体内是有定义的，不仅仅是在循环内</div><div class="line">            console.log(k); // 输出数字0~9</div><div class="line">        &#125;</div><div class="line">        console.log(k); // k已经定义了，输出10</div><div class="line">    &#125;</div><div class="line">    console.log(j); // j已经定义了，但可能没有初始化</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部，看一下如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可能会误以为函数中的第一行会输出 “global”，因为代码还没有执行到 var 语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到 var 语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope;          <span class="comment">// 在函数顶部声明了局部变量</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 变量存在，但其值是"undefined"</span></div><div class="line">    scope = <span class="string">"local"</span>;    <span class="comment">// 这里将其初始化并赋值</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 这里它具有了我们所期望的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。</p>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (color === <span class="string">"blue"</span>)&#123;</div><div class="line">        color = <span class="string">"red"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        color = <span class="string">"blue"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(changeColor());</div></pre></td></tr></table></figure>
<p>在这个简单的例子中，函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（其中定义着 arguments 对象）和全局环境的变量对象。可以在函数内部访问变量 color，就是因为可以在这个作用域链中找到它。</p>
<p>此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line"></div><div class="line">        <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span></div><div class="line">    swapColors();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>// 这里只能访问color<br>changeColor();<br>以上代码共涉及3个执行环境：全局环境、changeColor() 的局部环境和 swapColors() 的局部环境。全局环境中有一个变量 color 和一个函数 changeColor()。changeColor() 的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors() 的函数，但它也可以访问全局环境中的变量 color。swapColors() 的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。无论全局环境还是 changeColor() 的局部环境都无权访问 tempColor。然而，在 swapColors() 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。下图形象地展示了前面这个例子的作用域链。<br><img src="/css/images/scope.jpg" alt=""></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>MDN 对闭包的定义：</p>
<p>闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。<br>《JavaScript 权威指南(第6版)》对闭包的定义：</p>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>
<p>《JavaScript 高级程序设计(第3版)》对闭包的定义：</p>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>上面这些定义都比较晦涩难懂，阮一峰的解释稍微好理解一些：</p>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。</p>
<h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><p>闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量（作用域链），另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;　　　</div><div class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">    add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fun2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = fun();　　</div><div class="line">result(); <span class="comment">// 1</span></div><div class="line">add();</div><div class="line">result(); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>在这段代码中，result 实际上就是函数 fun2。它一共运行了两次，第一次的值是 1，第二次的值是 2。这证明了，函数 fun 中的局部变量 n 一直保存在内存中，并没有在 fun 调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于 fun 是 fun2 的父函数，而 fun2 被赋给了一个全局变量，这导致 fun2 始终在内存中，而 fun2 的存在依赖于 fun，因此 fun 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是 add = function() { n += 1 } 这一行。首先，变量 add 前面没有使用 var 关键字，因此 add 是一个全局变量，而不是局部变量。其次，add 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，和 fun2 处于同一作用域，所以 add 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h4 id="计数器的困境"><a href="#计数器的困境" class="headerlink" title="计数器的困境"></a>计数器的困境</h4><p>我们再来看一个经典例子「计数器的困境」，假设你想统计一些数值，且该计数器在所有函数中都是可用的。你可以定义一个全局变量 counter 当做计数器，再定义一个 add() 函数来设置计数器递增。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 计数器现在为 3</span></div></pre></td></tr></table></figure></p>
<p>计数器数值在执行 add() 函数时发生变化。但问题来了，页面上的任何脚本都能改变计数器 counter，即便没有调用 add() 函数。如果我们将计数器 counter 定义在 add() 函数内部，就不会被外部脚本随意修改到计数器的值了。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 本意是想输出 3, 但事与愿违，输出的都是 1</span></div></pre></td></tr></table></figure></p>
<p>因为每次调用 add() 函数，计数器都会被重置为 0，输出的都是 1，这并不是我们想要的结果。闭包正好可以解决这个问题，我们在 add() 函数内部，再定义一个 plus() 内嵌函数（闭包），内嵌函数 plus() 可以访问父函数的 counter 变量。代码如下：</p>
<p>``javascript<br>function add() {<br>    var counter = 0;<br>    var plus = function() {counter += 1;}<br>    plus();<br>    return counter;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">接下来，只要我们能在外部访问 plus() 函数，并且确保 counter = 0 只执行一次，就能解决计数器的困境。代码如下：</div><div class="line"></div><div class="line">```javascript</div><div class="line">var add = function() &#123;</div><div class="line">    var counter = 0;</div><div class="line">    var plus = function() &#123;return counter += 1;&#125;</div><div class="line">    return plus;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var puls2 = add();</div><div class="line">console.log(puls2());</div><div class="line">console.log(puls2());</div><div class="line">console.log(puls2());</div><div class="line">// 计数器为 3</div></pre></td></tr></table></figure></p>
<p>计数器 counter 受 add() 函数的作用域保护，只能通过 puls2 方法修改。<br>这里当时想了好久都没明白过来，一直理解为执行puls2()就是调用了add()这个方法，然后一直重复执行var counter = 0<br>结果是我忽略了add()方法里面的 return plus<br>那么后面每次调用plus2()实际上是执行了的plus这个方法，并非一直执行的add()</p>
<h4 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h4><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或设置为 null，断开变量和内存的联系。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<p>JavaScript 闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量，理解闭包有助于编写出更有效也更简洁的代码。</p>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h3><p>谈到作用域和闭包就不得不说 this 关键字，虽然它们之间关联不大，但是它们一起使用却容易让人产生疑惑。下面列出了使用 this 的大部分场景，带大家一探究竟。</p>
<p>this 是 JavaScript 的关键字，指函数执行时的上下文，跟函数定义时的上下文无关。随着函数使用场合的不同，this 的值会发生变化。但是有一个总的原则，那就是 this 指代的是调用函数的那个对象。</p>
<h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><p>在全局上下文中，也就是在任何函数体外部，this 指代全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中，this 指代全局对象 window</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p>在函数上下文中，也就是在任何函数体内部，this 指代调用函数的那个对象。</p>
<h4 id="函数调用中的-this"><a href="#函数调用中的-this" class="headerlink" title="函数调用中的 this"></a>函数调用中的 this</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，直接定义一个函数 f1()，相当于为 window 对象定义了一个属性。直接执行函数 f1()，相当于执行 window.f1()。所以函数 f1() 中的 this 指代调用函数的那个对象，也就是 window 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>; <span class="comment">// 这里是严格模式</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a>对象方法中的 this</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>如上代码所示，对象 o 中包含一个属性 name 和一个方法 f()。当我们执行 o.f() 时，方法 f() 中的 this 指代调用函数的那个对象，也就是对象 o，所以 this.name 也就是 o.name。</p>
<p>注意，在何处定义函数完全不会影响到 this 的行为，我们也可以首先定义函数，然后再将其附属到 o.f。这样做 this 的行为也一致。如下代码所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">name</span>: <span class="string">"stone"</span> &#125;;</div><div class="line">o.f = fun;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure></p>
<p>类似的，this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 g() 当作对象 o.b 的函数调用。在这次执行期间，函数中的 this 将指向 o.b。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.b = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"sophie"</span>,</div><div class="line">    <span class="attr">g</span>: fun</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b.g()); <span class="comment">// "sophie"</span></div></pre></td></tr></table></figure></p>
<h4 id="eval-方法中的-this"><a href="#eval-方法中的-this" class="headerlink" title="eval() 方法中的 this"></a>eval() 方法中的 this</h4><p>eval() 方法可以将字符串转换为 JavaScript 代码，使用 eval() 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval() 方法，调用者的执行环境中的 this 就被 eval() 方法继承下来了。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 函数上下文</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this.name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<h4 id="call-和-apply-方法中的-this"><a href="#call-和-apply-方法中的-this" class="headerlink" title="call() 和 apply() 方法中的 this"></a>call() 和 apply() 方法中的 this</h4><p>call() 和 apply() 是函数对象的方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指代的就是这两个方法的第一个参数。<br>更多apply()知识点见 <a href="http://www.xqiao.cc/conding/JavaScript/20160628/apply%20call%20bind.html" target="_blank" rel="external">apply call bind使用详解</a> 篇<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0</span>;　　</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;　　　　</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);　　</div><div class="line">&#125;　　</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;　　</div><div class="line">o.x = <span class="number">1</span>;</div><div class="line">o.m = f;　　</div><div class="line">o.m.apply(); <span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<p>call() 和 apply() 的参数为空时，默认调用全局对象。因此，这时的运行结果为 0，证明 this 指的是全局对象。如果把最后一行代码修改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.m.apply(o); <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>运行结果就变成了 1，证明了这时 this 指代的是对象 o</p>
<h4 id="bind-方法中的-this"><a href="#bind-方法中的-this" class="headerlink" title="bind() 方法中的 this"></a>bind() 方法中的 this</h4><p>ECMAScript 5 引入了 Function.prototype.bind。调用 f.bind(someObject) 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f.bind(&#123;</div><div class="line">    <span class="attr">a</span>: <span class="string">"stone"</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// stone</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">28</span>,</div><div class="line">    <span class="attr">f</span>: f,</div><div class="line">    <span class="attr">g</span>: g</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 28, stone</span></div></pre></td></tr></table></figure>
<h4 id="DOM-事件处理函数中的-this"><a href="#DOM-事件处理函数中的-this" class="headerlink" title="DOM 事件处理函数中的 this"></a>DOM 事件处理函数中的 this</h4><p>一般来讲，当函数使用 <code>addEventListener</code> 被用作事件处理函数时，它的 this 指向触发事件的元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.style.backgroundColor = <span class="string">"#A5D9F3"</span>;</div><div class="line">        &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但在 IE 浏览器中，当函数使用 <code>attachEvent</code> ，被用作事件处理函数时，它的 this 却指向 window。如下代码所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="内联事件处理函数中的-this"><a href="#内联事件处理函数中的-this" class="headerlink" title="内联事件处理函数中的 this"></a>内联事件处理函数中的 this</h4><p>当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素。如下代码所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的 alert 会显示 button，注意只有外层代码中的 this 是这样设置的。如果 this 被包含在匿名函数中，则又是另外一种情况了。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</div><div class="line">  Show inner <span class="keyword">this</span></div><div class="line">&lt;<span class="regexp">/button&gt;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，this 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 window 对象。</p>
<h3 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h3><p>仔细想想，下面代码块会输出什么结果呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func2;</div><div class="line">&#125;</div><div class="line">func1()();  <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二</span></div><div class="line">scope = <span class="string">"stone"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"sophie"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(scope);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> inner;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ret = Func();</div><div class="line">ret();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三</span></div><div class="line">scope = <span class="string">"stone"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"sophie"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(scope);</div><div class="line">    &#125;</div><div class="line">    scope = <span class="string">"tommy"</span>;</div><div class="line">    <span class="keyword">return</span> inner;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ret = Func();</div><div class="line">ret();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战四</span></div><div class="line">scope = <span class="string">"stone"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(scope);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"sophie"</span>;</div><div class="line">    <span class="keyword">return</span> Bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ret = Func();</div><div class="line">ret();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战五</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;　　</div><div class="line"><span class="keyword">var</span> object = &#123;　　　　</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　　　</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;　　　　　　</div><div class="line">        &#125;;　　　　</div><div class="line">    &#125;　　</div><div class="line">&#125;;　　</div><div class="line"><span class="built_in">console</span>.log(object.getNameFunc()());    <span class="comment">// ???</span></div><div class="line"><span class="comment">//提示： getNameFunc里面有一个匿名函数</span></div><div class="line"><span class="keyword">this</span> 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 <span class="built_in">window</span> 对象。</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战六</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;　　</div><div class="line"><span class="keyword">var</span> object = &#123;　　　　</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　</div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;　　　　　　</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　　　</div><div class="line">            <span class="keyword">return</span> that.name;　　　　　　</div><div class="line">        &#125;;　　　　</div><div class="line">    &#125;　　</div><div class="line">&#125;;　　</div><div class="line"><span class="built_in">console</span>.log(object.getNameFunc()());    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
        
        
      
    </div>
    <footer class="article-footer">
    	
        <a href="/conding/JavaScript/20170218/JS作用域和闭包.html#disqus_thread" class="article-comment-link">评论</a>
      

      <div class="bdsharebuttonbox"><span >分享到：</span><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["qzone","weixin","fbook","tqq","twi","sqq","tsina","tieba","linkedin"],"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","weixin","tsina","twi","fbook"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","weixin","tsina","twi","fbook"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作用域/">作用域</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/闭包/">闭包</a></li></ul>

 
     
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/uncategorized/20170220/react评论框实例.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          react评论框实例
        
      </div>
    </a>
  
  
    <a href="/conding/CSS/20170218/CSS3中的clip-path使用攻略.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">CSS3中的clip-path使用攻略</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-JS作用域和闭包" data-title="JS作用域和闭包" data-url="/conding/JavaScript/20170218/JS作用域和闭包.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类 ● category</h3>
    <div class="widget tag">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/conding/">技术</a><span class="category-list-count">57</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/conding/CSS/">CSS</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/D3-js/">D3.js</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/ES6/">ES6</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/JavaScript/">JavaScript</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/Jquery/">Jquery</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/React/">React</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/Webpack/">Webpack</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/npm/">npm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/conding/yarn/">yarn</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章 ● Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/conding/20180409/JS中常用数据转换方法.html">JS中常用数据转换方法</a>
          </li>
        
          <li>
            <a href="/conding/20180403/redux-saga.html">redux-saga</a>
          </li>
        
          <li>
            <a href="/conding/20180318/react子组件向父组件通信.html">react子组件向父组件通信</a>
          </li>
        
          <li>
            <a href="/conding/yarn/20180306/yarn更改为淘宝镜像.html">yarn更改为淘宝镜像</a>
          </li>
        
          <li>
            <a href="/conding/20180304/前端经验总结.html">前端经验总结(CSS)</a>
          </li>
        
          <li>
            <a href="/life/20171226/2017年又结束了.html">2017年又结束了</a>
          </li>
        
          <li>
            <a href="/uncategorized/20170824/svg动画（多个元素绕同一路径匀速运动）.html">svg动画（多个元素绕同一路径匀速运动）</a>
          </li>
        
          <li>
            <a href="/conding/20170818/node版本管理.html">node版本管理</a>
          </li>
        
          <li>
            <a href="/conding/JavaScript/20170404/你真的了解-console-吗.html">你真的了解 console 吗</a>
          </li>
        
          <li>
            <a href="/uncategorized/20170314/echarts-总结.html">echarts 总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云 ● Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 15.2px; color: #5189ab">CSS</a> <a href="/tags/CSS3/" style="font-size: 15.2px; color: #5189ab">CSS3</a> <a href="/tags/D3/" style="font-size: 20px; color: #ff7379">D3</a> <a href="/tags/ES6/" style="font-size: 14px; color: #258fb8">ES6</a> <a href="/tags/Echarts/" style="font-size: 14px; color: #258fb8">Echarts</a> <a href="/tags/Github/" style="font-size: 14px; color: #258fb8">Github</a> <a href="/tags/JSX/" style="font-size: 14px; color: #258fb8">JSX</a> <a href="/tags/JS兼容性/" style="font-size: 14px; color: #258fb8">JS兼容性</a> <a href="/tags/JS刷新/" style="font-size: 14px; color: #258fb8">JS刷新</a> <a href="/tags/JavaScript/" style="font-size: 18.8px; color: #d37986">JavaScript</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #258fb8">MongoDB</a> <a href="/tags/React/" style="font-size: 17.6px; color: #a87e92">React</a> <a href="/tags/SVG/" style="font-size: 14px; color: #258fb8">SVG</a> <a href="/tags/Webpack/" style="font-size: 14px; color: #258fb8">Webpack</a> <a href="/tags/console/" style="font-size: 14px; color: #258fb8">console</a> <a href="/tags/javascript/" style="font-size: 16.4px; color: #7c849f">javascript</a> <a href="/tags/npm/" style="font-size: 14px; color: #258fb8">npm</a> <a href="/tags/props/" style="font-size: 14px; color: #258fb8">props</a> <a href="/tags/react/" style="font-size: 20px; color: #ff7379">react</a> <a href="/tags/redux-saga/" style="font-size: 14px; color: #258fb8">redux-saga</a> <a href="/tags/yarn/" style="font-size: 14px; color: #258fb8">yarn</a> <a href="/tags/作用域/" style="font-size: 14px; color: #258fb8">作用域</a> <a href="/tags/单位/" style="font-size: 14px; color: #258fb8">单位</a> <a href="/tags/原型链/" style="font-size: 14px; color: #258fb8">原型链</a> <a href="/tags/友谊/" style="font-size: 15.2px; color: #5189ab">友谊</a> <a href="/tags/循环遍历/" style="font-size: 16.4px; color: #7c849f">循环遍历</a> <a href="/tags/总结/" style="font-size: 14px; color: #258fb8">总结</a> <a href="/tags/旅途/" style="font-size: 16.4px; color: #7c849f">旅途</a> <a href="/tags/比例尺/" style="font-size: 14px; color: #258fb8">比例尺</a> <a href="/tags/生命周期/" style="font-size: 14px; color: #258fb8">生命周期</a> <a href="/tags/解构赋值/" style="font-size: 14px; color: #258fb8">解构赋值</a> <a href="/tags/跨域/" style="font-size: 14px; color: #258fb8">跨域</a> <a href="/tags/键盘事件/" style="font-size: 14px; color: #258fb8">键盘事件</a> <a href="/tags/闭包/" style="font-size: 15.2px; color: #5189ab">闭包</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档 ● archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年 04月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年 03月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年 12月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年 08月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年 04月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年 03月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年 02月</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年 01月</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年 12月</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年 08月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年 07月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年 06月</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年 02月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年 01月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015年 12月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015年 08月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015年 05月</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
  <h3 class="widget-title">友情链接 ● Links</h3>
  <ul class="widget">
    
    <li><a href="http://baizn.github.io" target="_BLANK">●&emsp;baizn</a></li>
    
    <li><a href="http://init.funlee.cn" target="_BLANK">●&emsp;ClassRun</a></li>
    
    <li><a href="https://wxxtqk.github.io" target="_BLANK">●&emsp;tangqk</a></li>
    
    <li><a href="http://zy380196088.github.io" target="_BLANK">●&emsp;zy380196088</a></li>
    
    <li><a href="https://erikison18.github.io/" target="_BLANK">●&emsp;Erik</a></li>
    
  </ul>
</div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zillah<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    <span id="busuanzi_container_site_pv">
        总访问量 <a href="http://service.ibruce.info/" target="_blank"><span id="busuanzi_value_site_pv"></span></a> 次
      </span>
      <span id="busuanzi_container_site_uv">
        <a href="http://service.ibruce.info/" target="_blank"><span id="busuanzi_value_site_uv"></span></a> 人
      </span>

    </div>
  </div>

  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?204bdccab804777b4dcd9eefa8ceb91b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/categories/conding" class="mobile-nav-link">学无止境</a>
  
    <a href="/categories/life" class="mobile-nav-link">碎言碎语</a>
  
    <a href="/about" class="mobile-nav-link">关于我</a>
  
</nav>
    
<script>
  var disqus_shortname = 'jody';
  
  var disqus_url = '/conding/JavaScript/20170218/JS作用域和闭包.html';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="http://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js"></script>
<script type="text/javascript">
//<![CDATA[
if (typeof jQuery == 'undefined') {
  document.write(unescape("%3Cscript src='/js/jquery.min.js' type='text/javascript'%3E%3C/script%3E"));
}
// ]]>
</script>

<script src="/js/totop.js"></script>
<div id="totop" style="position:fixed;bottom:50px;right:30px;cursor: pointer;z-index:999; display:none">
<a title="返回顶部"><img src="/css/images/scrollup.png"/></a>
</div



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<!-- Baidu Share Start --->
<script>window._bd_share_config={"common":{"bdSnsKey":{"tsina":"1714312189"},"bdWbuid":3904642734,"bdText":"","bdMini":"2","bdMiniList":["douban","kaixin001","tieba","tsohu","sqq","youdao","qingbiji","mail","linkedin","mshare","copy","print"],"bdPic":"http://www.devchen.com/SharePic.png","bdStyle":"1","bdSize":"24"},"share":{"bdSize":16}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<!--- Baidu Share End --->






  </div>
</body>
</html>